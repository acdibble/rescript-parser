// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__List from "@rescript/core/src/Core__List.res.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Core__Result from "@rescript/core/src/Core__Result.res.mjs";

function reduce(list, fn) {
  var rest = list.slice(1);
  var first = Core__Option.getExn(list[0], undefined);
  return Core__Array.reduce(rest, first, fn);
}

function run(parser, input) {
  return parser._0(input);
}

function label(parser, label$1) {
  return {
          TAG: "Parser",
          _0: (function (input) {
              return Core__Result.mapError(run(parser, input), (function (param) {
                            return "Expected " + label$1;
                          }));
            })
        };
}

function $$char(v) {
  return {
          TAG: "Parser",
          _0: (function (string) {
              var ch = string[0];
              if (ch !== undefined) {
                if (v === ch) {
                  return {
                          TAG: "Ok",
                          _0: [
                            v,
                            string.slice(1)
                          ]
                        };
                } else {
                  return {
                          TAG: "Error",
                          _0: "Expected " + v
                        };
                }
              } else {
                return {
                        TAG: "Error",
                        _0: "Unexpected end of input"
                      };
              }
            })
        };
}

function andThen(parser1, parser2) {
  return {
          TAG: "Parser",
          _0: (function (input) {
              var error = run(parser1, input);
              if (error.TAG !== "Ok") {
                return error;
              }
              var match = error._0;
              var error$1 = run(parser2, match[1]);
              if (error$1.TAG !== "Ok") {
                return error$1;
              }
              var match$1 = error$1._0;
              return {
                      TAG: "Ok",
                      _0: [
                        [
                          match[0],
                          match$1[0]
                        ],
                        match$1[1]
                      ]
                    };
            })
        };
}

function orElse(parser1, parser2) {
  return {
          TAG: "Parser",
          _0: (function (input) {
              var result = run(parser1, input);
              if (result.TAG === "Ok") {
                return result;
              } else {
                return run(parser2, input);
              }
            })
        };
}

function map(parser, fn) {
  return {
          TAG: "Parser",
          _0: (function (input) {
              var error = run(parser, input);
              if (error.TAG !== "Ok") {
                return error;
              }
              var match = error._0;
              return {
                      TAG: "Ok",
                      _0: [
                        fn(match[0]),
                        match[1]
                      ]
                    };
            })
        };
}

function choice(parsers) {
  return reduce(parsers, orElse);
}

function anyOf(chars) {
  return reduce(chars.map($$char), orElse);
}

function sequence(parsers) {
  var concatResults = function (p1, p2) {
    return map(andThen(p1, p2), (function (param) {
                  return Core__List.concat(param[0], param[1]);
                }));
  };
  return reduce(parsers.map(function (p) {
                  return map(p, (function (x) {
                                return {
                                        hd: x,
                                        tl: /* [] */0
                                      };
                              }));
                }), concatResults);
}

function many(parser) {
  var inner = function (input) {
    var match = run(parser, input);
    if (match.TAG !== "Ok") {
      return [
              /* [] */0,
              input
            ];
    }
    var match$1 = match._0;
    var match$2 = inner(match$1[1]);
    return [
            {
              hd: match$1[0],
              tl: match$2[0]
            },
            match$2[1]
          ];
  };
  return {
          TAG: "Parser",
          _0: (function (input) {
              return {
                      TAG: "Ok",
                      _0: inner(input)
                    };
            })
        };
}

function many1(parser) {
  return map(andThen(map(parser, (function (v) {
                        return {
                                hd: v,
                                tl: /* [] */0
                              };
                      })), many(parser)), (function (param) {
                return Core__List.concat(param[0], param[1]);
              }));
}

function opt(parser) {
  var inner = function (input) {
    var match = run(parser, input);
    if (match.TAG !== "Ok") {
      return {
              TAG: "Ok",
              _0: [
                undefined,
                input
              ]
            };
    }
    var match$1 = match._0;
    var rest = match$1[1];
    var value = match$1[0];
    var match$2 = inner(rest);
    if (match$2.TAG === "Ok" && match$2._0[0] !== undefined) {
      return {
              TAG: "Error",
              _0: "Expected value"
            };
    } else {
      return {
              TAG: "Ok",
              _0: [
                Caml_option.some(value),
                rest
              ]
            };
    }
  };
  return {
          TAG: "Parser",
          _0: inner
        };
}

function keepLeft(parser1, parser2) {
  return map(andThen(parser1, parser2), (function (param) {
                return param[0];
              }));
}

function keepRight(parser1, parser2) {
  return map(andThen(parser1, parser2), (function (param) {
                return param[1];
              }));
}

function between(parser1, parser2, parser3) {
  return keepLeft(keepRight(parser1, parser2), parser3);
}

function sepBy1(parser, sep) {
  return {
          TAG: "Parser",
          _0: (function (input) {
              var error = run(parser, input);
              if (error.TAG !== "Ok") {
                return error;
              }
              var match = error._0;
              var value = match[0];
              return run(map(many(keepRight(sep, parser)), (function (__x) {
                                return Core__List.concat({
                                            hd: value,
                                            tl: /* [] */0
                                          }, __x);
                              })), match[1]);
            })
        };
}

function sepBy(parser, sep) {
  return map(sepBy1(opt(parser), sep), (function (__x) {
                return Core__List.filterMap(__x, (function (x) {
                              return x;
                            }));
              }));
}

function satisfy(fn) {
  return {
          TAG: "Parser",
          _0: (function (input) {
              var ch = input[0];
              if (ch !== undefined) {
                if (fn(ch)) {
                  return {
                          TAG: "Ok",
                          _0: [
                            ch,
                            input.slice(1)
                          ]
                        };
                } else {
                  return {
                          TAG: "Error",
                          _0: "Unexpected character " + ch
                        };
                }
              } else {
                return {
                        TAG: "Error",
                        _0: "Unexpected end of input"
                      };
              }
            })
        };
}

function string(str) {
  return map(map(sequence(str.split("").map($$char)), (function (v) {
                    return Core__List.toArray(v);
                  })), (function (v) {
                return v.join("");
              }));
}

function makeRecursive(fn) {
  var parserRef = {
    contents: {
      TAG: "Parser",
      _0: (function (param) {
          return PervasivesU.failwith("Not implemented");
        })
    }
  };
  parserRef.contents = fn({
        TAG: "Parser",
        _0: (function (input) {
            return run(parserRef.contents, input);
          })
      });
  return parserRef.contents;
}

export {
  reduce ,
  run ,
  label ,
  $$char ,
  andThen ,
  orElse ,
  map ,
  choice ,
  anyOf ,
  sequence ,
  many ,
  many1 ,
  opt ,
  keepLeft ,
  keepRight ,
  between ,
  sepBy1 ,
  sepBy ,
  satisfy ,
  string ,
  makeRecursive ,
}
/* No side effect */
